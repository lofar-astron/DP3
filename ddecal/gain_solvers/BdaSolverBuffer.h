// Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
// SPDX-License-Identifier: GPL-3.0-or-later

#ifndef DDECAL_BDA_SOLVER_BUFFER_H
#define DDECAL_BDA_SOLVER_BUFFER_H

#include <dp3/base/BdaBuffer.h>

#include <aocommon/queue.h>

#include <cmath>
#include <complex>
#include <memory>
#include <vector>

namespace dp3 {
namespace ddecal {

class BdaSolverBuffer {
 public:
  /// Holds information for similar rows in different BdaBuffers.
  /// Each IntervalRow corresponds to one BDA row from an input BdaBuffer.
  /// It contains meta data for that row and pointers to the different
  /// visibilities (unweighted, weighted, and model visibilities).
  /// The pointers do not own the data. They point to BdaBuffers in data_.
  struct IntervalRow {
    double time;
    std::size_t baseline_nr;
    std::size_t n_channels;
    std::size_t n_correlations;
    std::complex<float>* unweighted_data;
    const std::complex<float>* weighted_data;
    const bool* flags;
    const float* weights;
    std::vector<std::complex<float>*> unweighted_model_data;
    std::vector<const std::complex<float>*> weighted_model_data;
  };

  /**
   * Constructor.
   * @param start Start time of the first solution interval.
   * @param interval Length of a solution interval. Should be > 0.0.
   * @param n_baselines The number of baselines.
   */
  BdaSolverBuffer(double start, double interval, size_t n_baselines)
      : data_(),
        time_start_(start),
        time_interval_(interval),
        current_interval_(0),
        last_complete_interval_per_baseline_(n_baselines, -1),
        data_rows_() {
    assert(interval > 0.0);
    // Ensure that the current solution interval is valid.
    data_rows_.PushBack(std::vector<IntervalRow>());
  }

  /**
   * This function takes a buffer with unweighted data and the corresponding
   * weights. It weights these data buffers and stores the result internally.
   * @param buffer A buffer with unweighted data, unweighted model data
   * for each direction, weights and flags.
   * @param direction_names The names of the model data buffers in 'buffer'.
   * @param keep_unweighted_model_data
   * True: Keep the original unweighted model data. GetDone() will
   *       return the original buffers, including that model data.
   * False: Delete the unweighted model data. GetDone() will
   *        return buffers without any model data for the given directions.
   */
  void AppendAndWeight(std::unique_ptr<base::BdaBuffer> buffer,
                       const std::vector<std::string>& direction_names,
                       bool keep_unweighted_model_data);

  /**
   * Clears all internal buffers.
   * Does not affect the solution interval and the number of directions.
   */
  void Clear();

  /**
   * @return True if the current solution interval is complete. An interval
   * is complete if the solver buffer contains a BDA row with a start time
   * greater or equal to the end time of the current solution interval.
   */
  bool IntervalIsComplete() const {
    return *std::min_element(last_complete_interval_per_baseline_.begin(),
                             last_complete_interval_per_baseline_.end()) >= 0;
  }

  /**
   * Advances the current solution interval to the next interval.
   * Releases all internal buffers that only hold data for previous solution
   * intervals.
   */
  void AdvanceInterval();

  /**
   * Get the number of active buffers, which is the number of AppendAndWeight()
   * calls minus the number of buffers that AdvanceInterval() released.
   * @return The number of active buffers.
   */
  size_t BufferCount() const { return data_.Size(); }

  /**
   * Get the content for the current solution interval. It consists of meta
   * data and pointers to visibilities (weighted, unweighted, and model
   * visibilities) for each BDA row.
   */
  const std::vector<IntervalRow>& GetIntervalRows() const {
    return data_rows_[0];
  }

  /**
   * @return The absolute index of the current solution interval.
   */
  int GetCurrentInterval() const { return current_interval_; }

  /**
   * Apply solutions to the predicted model and subtract the result from the
   * (unweighted) input data buffer, which was supplied to AppendAndWeight.
   * @param solutions Solutions generated by a BdaSolver.
   * @param chan_block_start_freqs Start frequencies for each channel block.
   * This vector has (n_channel_blocks + 1) items: The start frequency of a
   * block is the end frequency of the previous block.
   * @param n_polarizations Number of polarizations in the solution. Should be
   * 1, 2 or 4.
   * @param ant1 For each baseline, the index of the first antenna.
   * @param ant2 For each baseline, the index of the second antenna.
   * @param chan_freqs For each baseline, the center frequencies of all BDA
   * rows.
   */
  void SubtractCorrectedModel(
      const std::vector<std::vector<std::complex<double>>>& solutions,
      const std::vector<double>& chan_block_start_freqs, size_t n_polarizations,
      const std::vector<int>& ant1, const std::vector<int>& ant2,
      const std::vector<std::vector<double>>& chan_freqs);

  /**
   * Retrieve all unweighted input buffers which only hold data for previous
   * solution intervals. The BdaSolverBuffer is done processing those buffers.
   * The BdaSolverBuffer returns the buffers in the same order as they were
   * added using AppendAndWeight().
   * @return A possibly empty list of processed unweighted input buffers.
   */
  std::vector<std::unique_ptr<base::BdaBuffer>> GetDone() {
    std::vector<std::unique_ptr<base::BdaBuffer>> result;
    result.swap(done_);
    return result;
  }

  /**
   * Start time of the current interval. This interval will not have any
   * visibilities for which the time centroid is smaller than this value.
   */
  double CurrentIntervalStart() const {
    return time_start_ + current_interval_ * time_interval_;
  }

  /**
   * Duration of this interval. Given that visibilities are placed
   * in an interval based on their centroid, this is the maximum
   * difference between the centroid times of visibilities in the
   * same interval, and is always larger than zero.
   */
  double IntervalDuration() const { return time_interval_; }

 private:
  /**
   * @param time_center Center time of a measurement / BDA row.
   * @return The relative solution interval index for a given time.
   */
  int RelativeIndex(double time_center) const {
    return int(std::floor((time_center - time_start_) / time_interval_)) -
           current_interval_;
  }

  /**
   * The BDASolverBuffer is the owner of both the unweighted and the weighted
   * input data. The data flow is:
   * 1. AppendAndWeight receives unweighted data, weights it, and stores both
   *    the unweighted and the corresponding weighted data in data_.
   * 2. A Solver accesses the weighted data via GetDataRows and
   *    GetModelDataRows, via a SolveData structure.
   * 3. SubtractCorrectedModel() applies the solutions to the model data and
   *    subtracts them from the unweighted data.
   * 4. When a BDA buffer is no longer needed, AdvanceInterval deletes the
   *    weighted data and moves the unweighted data to done_.
   * 5. GetDone() extracts the buffers from done_.
   */
  struct InputData {
    std::unique_ptr<base::BdaBuffer> unweighted;
    std::unique_ptr<base::BdaBuffer> weighted;
  };

  /// A FIFO queue with input data. AppendAndWeight appends items.
  aocommon::Queue<InputData> data_;

  /// Fully processed input buffers.
  std::vector<std::unique_ptr<base::BdaBuffer>> done_;

  /// Start time of the first solution interval (seconds).
  const double time_start_;
  const double time_interval_;  ///< Solution interval length (seconds).
  int current_interval_;  ///< Absolute index of the current solution interval.

  /// Index of the last complete solution interval per each baseline, relative
  /// to the current solution interval. The value is negative if no interval is
  /// complete.
  std::vector<int> last_complete_interval_per_baseline_;

  /// The BDA rows for the current and future solution intervals.
  /// The queue contains one vector of IntervalRows for each solution interval.
  /// The queue always contains one element for the current solution interval.
  /// @see IntervalRow
  aocommon::Queue<std::vector<IntervalRow>> data_rows_;
};

}  // namespace ddecal
}  // namespace dp3

#endif  // DDECAL_BDA_SOLVER_BUFFER_H
